'use strict';
require('dotenv').config({ path: __dirname + "/../../../../.env" });
const { TasksStatus } = require('../models/TasksStatus');
const configDB  = require("../../database/config/config");
const DBConnectionManager = require('../DBConnectionManager');
const { QueryTypes } = require('sequelize');
const { Utils } = require('../../controllers/utils/Utils');
const { Tables } = require('../models/Tables');
const { Modules } = require('../models/Modules');
const { Routines } = require('../models/Routines');
const { Connections } = require('../models/Connections');

/** @type {import('sequelize-cli').Migration} */


let oldTables = {  
  allTables : {
    allColumns: (old) => old.toLowerCase(),
    columns:{
      IDSTATUSREG: 'status_reg_id',
      IDUSERCREATE: 'creator_user_id',
      CREATEDAT: 'created_at',
      IDUSERUPDATE: 'updater_user_id',
      UPDATEDAT: 'updated_at',
      IDORIGINDATA: 'data_origin_id',
      IDONORIGINDATA: 'id_at_origin',
      DELETEDAT: 'deleted_at',
      ISSYSTEMREG: 'is_sys_rec'
    }
  },
  tables:{
    tableName:"DATATABLES"
  },
  connections:{
    tableName:"DATACONNECTIONS"
  },
  schemas:{
    tableName:"DATASCHEMAS"
  },
  entities_types:{
    tableName:"ENTITIESTYPES"
  },
  data_types:{
    tableName:"DATATYPES"
  },  
  action_status:{
    tableName:"ACTIONSSTATUS"
  },
  parameter_values:{
    tableName:"PARAMETERSVALUES"
  },
  data_origins:{
    tableName:"ORIGINSDATAS"
  },
  access_profiles:{
    tableName:"ACCESSESPROFILES"
  },  
  address_types:{
    tableName:"ADDRESSESTYPES"
  },
  api_requests:{
    tableName:"APISREQUESTS"
  },
  api_request_calls:{
    tableName:"APISREQUESTSCALLS"
  },
  api_responses:{
    tableName:"APISRESPONSES"
  },
  
  maps_api_responses:{
    tableName:"APISMAPSRESPONSES"
  },
  warehouse_address_types:{
    tableName: "WAREHOUSESADDRESSESTYPES"
  }
}

module.exports = {

  /**
   * Migrate all data of all tables if exists old connection and exists old database
   * @param {*} queryInterface 
   * @param {*} Sequelize 
   */
  async up (queryInterface, Sequelize) {        

    async function migrateDataOldTable(pOldConnection,pOlddSchemaName,pNewTableName) {
      try {
        let oldTableName = pNewTableName;
        let keyOldTable = Utils.getKey(oldTables,oldTableName);
        let oldTable = null;
        if (Utils.hasValue(keyOldTable)) {
          oldTable = oldTables[keyOldTable];
          oldTableName = oldTable.tableName || oldTableName;
        }

        let regs = await pOldConnection.query(`
          select 
            t.* 
          from 
            ${pOlddSchemaName}.${oldTableName} t
          order by 1`,
          {raw:true,queryType: QueryTypes.SELECT}        
        );
        if (regs && regs.length) {
          //Utils.log('FL','regs',regs.length);
          let describeNew = await queryInterface.describeTable(pNewTableName);
          let fields = Object.keys(describeNew).join(',').toLowerCase().split(',');
          let newRegs = regs[0];
          if (newRegs && newRegs.length) {
            Utils.log('FL','newRegs',newRegs.length);
            let allOldColumns = {};
            if (Utils.hasValue(oldTables.allTables.columns)) {              
              let correctOldColumnKey = null;
              for(let oldColumn in oldTables.allTables.columns) {                
                correctOldColumnKey = Utils.getKey(newRegs[0],oldColumn);                
                if (Utils.hasValue(correctOldColumnKey)) {                    
                  if (typeof oldTables.allTables?.allColumns == 'function') {
                    allOldColumns[oldTables.allTables.allColumns(correctOldColumnKey)] = oldTables.allTables.columns[oldColumn];                      
                  } else {
                    allOldColumns[correctOldColumnKey] = oldTables.allTables.columns[oldColumn];                      
                  }                                                 
                }                  
              }                            
            }
            Utils.log('FL','KEYS OLD',oldTableName,allOldColumns);

            if (Utils.hasValue(oldTable)) {
              let correctOldColumnKey = null;
              for(let oldColumn in oldTable.columns) {
                correctOldColumnKey = Utils.getKey(newRegs[0],oldColumn);
                if (Utils.hasValue(correctOldColumnKey)) {
                  if (typeof oldTables.allTables?.allColumns == 'function') {
                    allOldColumns[oldTables.allTables.allColumns(correctOldColumnKey)] = oldTable.columns[oldColumn];
                  } else {
                    allOldColumns[correctOldColumnKey] = oldTable.columns[oldColumn];
                  }
                }
              }
            }
            Utils.log('FL','KEYS OLD',oldTableName,allOldColumns);
            if (pNewTableName === 'users') Utils.log('newregs users inserting',newRegs);
            for(let index in newRegs) {

              if (Utils.hasValue(oldTables.allTables.allColumns)) {
                if (typeof oldTables.allTables.allColumns == 'function') {
                  for(let oldColumn in newRegs[index]) {
                    let newCol = oldTables.allTables.allColumns(oldColumn);
                    if (newCol != oldColumn) {
                      newRegs[index][newCol] = newRegs[index][oldColumn];
                      delete newRegs[index][oldColumn];
                    }
                  }
                } else {
                  throw new Error('do implement');
                }
              }

              if(Utils.hasValue(allOldColumns)) {
                for(let oldColumn in allOldColumns) {
                  if (Utils.hasValue(newRegs[index][oldColumn])) {
                    newRegs[index][allOldColumns[oldColumn]] = newRegs[index][oldColumn];
                    delete newRegs[index][oldColumn];
                  } else if (Utils.hasValue(Utils.getKey(newRegs[index],oldColumn))) {
                    delete newRegs[index][oldColumn];
                  }
                }
              }
              if (pNewTableName === 'users') Utils.log('newregs users inserting',newRegs[index]);
              Utils.deleteNotExistsProperty(newRegs[index],fields);
              if (pNewTableName === 'users') Utils.log('newregs users inserting',newRegs[index]);
            }         
            if (pNewTableName === 'users') Utils.log('newregs users inserting',newRegs);
            await queryInterface.bulkInsert(pNewTableName,newRegs,{
              ignoreDuplicates:true,
              updateOnDuplicate:null
            });
          } else {
            Utils.log('FL','no news regs');  
          }
        } else {
          Utils.log('FL','no regs');
        }
      } catch (e) {
        if (e.message.trim().toLowerCase().indexOf('unknown database ') === 0) {
          Utils.log('FL',`ignoring data migration table ${oldTableName}, schema ${pOlddSchemaName} not exists`);
        } else {
          Utils.log('FL',e);
        }
      }
    }
    
    let oldConnection = DBConnectionManager.getOldDBConnection();
    if (oldConnection) {
      let tables = await Tables.getModel().findAll({
        raw:true,
        where:{
          IDDATACONNECTION: configDB[`${process.env.NODE_ENV||'development'}`].id,//only tables of this coonnections can be data migrated 
          id:{

            //configure here ids of tables that whant excluded of this migration
            [Sequelize.Op.notIn] : [
              Connections.id,
              Tables.id,
              Modules.id,
              Routines.id
            ]
          }          
        },
        order:[['id']]
      });
      if (tables && tables.length) {
        let oldConfig = configDB[`${process.env.NODE_ENV||'development'}_old`] || {};
        for(let key in tables) {
          await migrateDataOldTable(oldConnection,oldConfig.database.toLowerCase(),tables[key].name.toLowerCase());  
        }
      }
    }     
  },

  async down (queryInterface, Sequelize) {
     await queryInterface.bulkDelete(TasksStatus.tableName, null, {});
  }
};
